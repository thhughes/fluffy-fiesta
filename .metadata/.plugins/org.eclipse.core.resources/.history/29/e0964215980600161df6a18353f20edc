package hanto.teststudentthhughes.delta;

/**
 * 
 */


import static hanto.common.HantoPieceType.CRAB;

import static hanto.common.HantoPieceType.CRANE;
import static hanto.common.HantoPieceType.DOVE;
import static hanto.common.HantoPieceType.HORSE;
import static hanto.common.HantoPieceType.SPARROW;
import static hanto.common.HantoPieceType.BUTTERFLY;

import static hanto.common.HantoPlayerColor.BLUE;
import static hanto.common.HantoPlayerColor.RED;
import static org.junit.Assert.*;

import org.junit.Before;
import org.junit.BeforeClass;
import org.junit.Test;

import hanto.common.HantoCoordinate;
import hanto.common.HantoException;
import hanto.common.HantoGame;
import hanto.common.HantoGameID;
import hanto.common.HantoPiece;
import hanto.common.HantoPieceType;
import hanto.common.HantoPlayerColor;
import hanto.common.MoveResult;
import hanto.studentthhughes.HantoGameFactory;

/**
 * @author Amanda
 * 
 * Test cases for Delta Hanto.
 */
public class DeltaHantoMasterTest {
	/**
	 * Internal class for these test cases.
	 * @version Sep 13, 2014
	 */
	class TestHantoCoordinate implements HantoCoordinate
	{
		private final int x, y;

		public TestHantoCoordinate(int x, int y)
		{
			this.x = x;
			this.y = y;
		}
		/*
		 * @see hanto.common.HantoCoordinate#getX()
		 */
		@Override
		public int getX()
		{
			return x;
		}

		/*
		 * @see hanto.common.HantoCoordinate#getY()
		 */
		@Override
		public int getY()
		{
			return y;
		}

	}

	class TestHantoPiece implements HantoPiece {
		private final HantoPlayerColor color;
		private final HantoPieceType type;

		public TestHantoPiece(HantoPlayerColor newColor, HantoPieceType newType) {
			color = newColor;
			type = newType;
		}

		@Override
		public HantoPlayerColor getColor() {
			return color;
		}

		@Override
		public HantoPieceType getType() {
			return type;
		}

		public boolean samePiece(Object o) {
			if (o instanceof HantoPiece) {
				HantoPiece obj = (HantoPiece) o;
				if ((obj.getType() == type) && (obj.getColor() == color)) {
					return true;
				}
			}
			return false;
		}

	}


	private static HantoGameFactory factory;
	private HantoGame blueFirstGame;
	private HantoGame redFirstGame;

	@BeforeClass
	public static void initializeClass()
	{
		factory = HantoGameFactory.getInstance();
	}

	@Before
	public void setup()
	{
		// By default, blue moves first.
		blueFirstGame = factory.makeHantoGame(HantoGameID.DELTA_HANTO, BLUE);
		redFirstGame = factory.makeHantoGame(HantoGameID.DELTA_HANTO, RED);
	}

	// ------------------------- acceptance tests (taken from gamma hanto, where functionality is same) 
	// Test valid piece type

	@Test(expected = HantoException.class) // 2
	public void bluePlacesPieceCraneOnOriginAtStart() throws HantoException {
		blueFirstGame.makeMove(CRANE, null, mc(0,0));
	}

	@Test(expected = HantoException.class) // 3
	public void bluePlacesDovePieceOnOriginAtStart() throws HantoException {
		blueFirstGame.makeMove(DOVE, null, mc(0,0));
	}

	@Test(expected = HantoException.class) // 4
	public void bluePlacesHorsePieceOnOriginAtStart() throws HantoException {
		blueFirstGame.makeMove(HORSE, null, mc(0,0));
	}

	// test valid piece placement on start
	@Test
	public void correctPlacementOnStart() throws HantoException {
		MoveResult mr = blueFirstGame.makeMove(BUTTERFLY, null, mc(0, 0));
		assertEquals(MoveResult.OK, mr);
		assertTrue(new TestHantoPiece(BLUE, BUTTERFLY).samePiece(blueFirstGame.getPieceAt(mc(0, 0))));
	}

	@Test
	public void playSparrowOnStart() throws HantoException {
		MoveResult mr = redFirstGame.makeMove(SPARROW, null, mc(0, 0));
		assertEquals(MoveResult.OK, mr);
		assertTrue(new TestHantoPiece(RED, SPARROW).samePiece(redFirstGame.getPieceAt(mc(0, 0))));
	}

	@Test
	public void playCrabOnStart() throws HantoException {
		MoveResult mr = blueFirstGame.makeMove(CRAB, null, mc(0, 0));
		assertEquals(MoveResult.OK, mr);
		assertTrue(new TestHantoPiece(BLUE, CRAB).samePiece(blueFirstGame.getPieceAt(mc(0, 0))));
	}

	// play not at origin on start
	@Test (expected = HantoException.class)
	public void playNotAtOrigin() throws HantoException {
		blueFirstGame.makeMove(BUTTERFLY, null, mc(0,1));
	}

	@Test (expected = HantoException.class)
	public void fromNotNullOnStart() throws HantoException {
		redFirstGame.makeMove(SPARROW, mc(-1, 1), mc(0, 0));
	}

	// test valid piece placement on move 1 (must be adjacent)
	@Test
	public void redMakesValidSecondMove() throws HantoException {
		blueFirstGame.makeMove(BUTTERFLY, null, mc(0, 0));
		MoveResult mr = blueFirstGame.makeMove(SPARROW, null, mc(0, 1));
		assertEquals(MoveResult.OK, mr);
		assertTrue(new TestHantoPiece(RED, SPARROW).samePiece(blueFirstGame.getPieceAt(mc(0, 1))));
	}


	// test invalid piece placement on move 1 (discontinuous)
	@Test
	public void redMakesInvalidSecondMove() throws HantoException {
		blueFirstGame.makeMove(BUTTERFLY, null, mc(0, 0));
		try {
			blueFirstGame.makeMove(SPARROW, null, mc(0, 2));
			fail("Piece placement must be continuous");
		} catch (HantoException e) {
			// desired case
		}
	}

	@Test
	public void redTriesToMoveWhenNoPiecesPlaced() throws HantoException {
		blueFirstGame.makeMove(SPARROW, null, mc(0, 0));
		try {
			blueFirstGame.makeMove(SPARROW, mc(0, 0), mc(0, 1));
			fail("red should not be able to move piece placed by blue");
		} catch (HantoException e){
			// desired state
		}
	}

	@Test
	public void redTriesToMoveOnTopOfBlue() throws HantoException {
		blueFirstGame.makeMove(SPARROW, null, mc(0, 0));
		try {
			blueFirstGame.makeMove(SPARROW, null, mc(0, 0));
			fail("red should not be able to move on top of blue");
		} catch (HantoException e){
			// desired state
		}
	}



	// test valid piece placement in subsequent moves (adjacent only to same color on placement)
	@Test 
	public void secondPlacementNotNextToOtherColor() throws HantoException {
		blueFirstGame.makeMove(SPARROW, null, mc(0, 0));
		blueFirstGame.makeMove(SPARROW, null, mc(-1, 1));
		MoveResult mr  = blueFirstGame.makeMove(SPARROW, null, mc(1, 0));
		assertEquals(MoveResult.OK, mr);
		assertTrue(new TestHantoPiece(BLUE, SPARROW).samePiece(blueFirstGame.getPieceAt(mc(1, 0))));
	}

	@Test
	public void secondPlacementNextToBothPlaced() throws HantoException {
		redFirstGame.makeMove(SPARROW, null, mc(0, 0));
		redFirstGame.makeMove(SPARROW, null, mc(0, 1));
		try {
			redFirstGame.makeMove(SPARROW, null, mc(1, 0));
			fail("Red should only be able place pieces next to reds");
		} catch (HantoException e) {
			// desired state
		}		
	}

	@Test
	public void secondPlacementNextToOnlyOtherColor() throws HantoException {
		blueFirstGame.makeMove(SPARROW, null, mc(0, 0));
		blueFirstGame.makeMove(SPARROW, null, mc(0, 1));
		try {
			blueFirstGame.makeMove(SPARROW, null, mc(0, 2));
			fail("Blue should only be able place pieces next to blues");
		} catch (HantoException e) {
			// desired state
		}		
	}

	@Test
	public void secondRoundPlacementNotAdjacent() throws HantoException {
		blueFirstGame.makeMove(SPARROW, null, mc(0, 0));
		blueFirstGame.makeMove(SPARROW, null, mc(0, 1));
		blueFirstGame.makeMove(SPARROW, null, mc(0, -1));
		try {
			blueFirstGame.makeMove(SPARROW, null, mc(0, 5));
			fail("Pieces must be adjacent");
		} catch (HantoException e) {
			// desired state
		}	
	}

	@Test 
	public void bluePlaysButterflyTwice() throws HantoException {
		blueFirstGame.makeMove(BUTTERFLY, null, mc(0, 0));
		blueFirstGame.makeMove(BUTTERFLY, null, mc(1, -1));
		try {
			blueFirstGame.makeMove(BUTTERFLY, null, mc(2, -2));
			fail("Blue tried to place butterfly twice");
		} catch (HantoException e) {
			// desired state
		}
	}

	@Test 
	public void bluePlacesPieceWhereRedWent() throws HantoException {
		blueFirstGame.makeMove(BUTTERFLY, null, mc(0, 0));
		blueFirstGame.makeMove(BUTTERFLY, null, mc(1, -1));
		try {
			blueFirstGame.makeMove(SPARROW, null, mc(1, -1));
			fail("Blue tried to play in a spot already occupied");
		} catch (HantoException e) {
			// desired state
		}
	}

	@Test // 18
	public void redPlacesSecondButterfly() throws HantoException {
		blueFirstGame.makeMove(BUTTERFLY, null, mc(0, 0));
		blueFirstGame.makeMove(BUTTERFLY, null, mc(1, -1));
		blueFirstGame.makeMove(SPARROW, null, mc(-1, 1));
		try {
			blueFirstGame.makeMove(BUTTERFLY, null, mc(2, -2));
			fail("Red tried to play butterfly twice");
		} catch (HantoException e) {
			// desired state
		}
	}

	// test hasn't placed butterfly by fourth turn
	// blue and red
	@Test
	public void tryToNotPlayButterflyByFourthTurn() throws HantoException {
		blueFirstGame.makeMove(SPARROW, null, mc(0, 0));
		blueFirstGame.makeMove(SPARROW, null, mc(1, -1));
		blueFirstGame.makeMove(SPARROW, null, mc(-1, 1));
		blueFirstGame.makeMove(SPARROW, null, mc(2, -2));
		blueFirstGame.makeMove(SPARROW, null, mc(-2, 2));
		blueFirstGame.makeMove(SPARROW, null, mc(3, -3));
		try {
			blueFirstGame.makeMove(SPARROW, null, mc(-3, 3));
			fail("Must play butterfly during or before fourth round");
		} catch (HantoException e) {
			// desired state
		}
	}

	@Test
	public void secondPlayerTryToNotPlayButterflyByFourthTurn() throws HantoException {
		blueFirstGame.makeMove(SPARROW, null, mc(0, 0));
		blueFirstGame.makeMove(SPARROW, null, mc(1, -1));
		blueFirstGame.makeMove(SPARROW, null, mc(-1, 1));
		blueFirstGame.makeMove(SPARROW, null, mc(2, -2));
		blueFirstGame.makeMove(SPARROW, null, mc(-2, 2));
		blueFirstGame.makeMove(SPARROW, null, mc(3, -3));
		blueFirstGame.makeMove(BUTTERFLY, null, mc(-3, 3));
		try {
			blueFirstGame.makeMove(SPARROW, null, mc(4, -4));
			fail("Must play butterfly during or before fourth round");
		} catch (HantoException e) {
			// desired state
		}
	}

	// test hasn't placed butterfly by fourth turn
	// blue and red
	@Test
	public void redFirstTryToNotPlayButterflyByFourthTurn() throws HantoException {
		redFirstGame.makeMove(SPARROW, null, mc(0, 0));
		redFirstGame.makeMove(SPARROW, null, mc(1, -1));
		redFirstGame.makeMove(SPARROW, null, mc(-1, 1));
		redFirstGame.makeMove(SPARROW, null, mc(2, -2));
		redFirstGame.makeMove(SPARROW, null, mc(-2, 2));
		redFirstGame.makeMove(SPARROW, null, mc(3, -3));
		try {
			redFirstGame.makeMove(SPARROW, null, mc(-3, 3));
			fail("Must play butterfly during or before fourth round");
		} catch (HantoException e) {
			// desired state
		}
	}

	@Test
	public void redFirstSecondPlayerTryToNotPlayButterflyByFourthTurn() throws HantoException {
		redFirstGame.makeMove(SPARROW, null, mc(0, 0));
		redFirstGame.makeMove(SPARROW, null, mc(1, -1));
		redFirstGame.makeMove(SPARROW, null, mc(-1, 1));
		redFirstGame.makeMove(SPARROW, null, mc(2, -2));
		redFirstGame.makeMove(SPARROW, null, mc(-2, 2));
		redFirstGame.makeMove(SPARROW, null, mc(3, -3));
		redFirstGame.makeMove(BUTTERFLY, null, mc(-3, 3));
		try {
			redFirstGame.makeMove(SPARROW, null, mc(4, -4));
			fail("Must play butterfly during or before fourth round");
		} catch (HantoException e) {
			// desired state
		}
	}


	// test trying to move before butterfly placed breaks (throw exception)
	// blue and red

	@Test
	public void tryToMoveSparrowBeforeButterflyPlayed() throws HantoException {
		redFirstGame.makeMove(SPARROW, null, mc(0, 0));
		redFirstGame.makeMove(BUTTERFLY, null, mc(1, 0));
		try {
			redFirstGame.makeMove(SPARROW, mc(0, 0), mc(1, -1));
			fail("Cannot move before own butterfly played");
		} catch (HantoException e) {
			// desired state
		}
	}

	// test can move 1 with open spaces
	@Test
	public void makeValidMoveAfterButterfly() throws HantoException {
		redFirstGame.makeMove(BUTTERFLY, null, mc(0, 0));
		redFirstGame.makeMove(BUTTERFLY, null, mc(1, 0));
		MoveResult mr = redFirstGame.makeMove(BUTTERFLY, mc(0, 0), mc(1, -1));
		assertEquals(MoveResult.OK, mr);
		assertNull(redFirstGame.getPieceAt(mc(0, 0)));
		assertTrue((new TestHantoPiece(RED, BUTTERFLY)).samePiece(redFirstGame.getPieceAt(mc(1, -1))));
	}

	@Test
	public void tryToMoveWithDiscontinuousResult() throws HantoException {
		redFirstGame.makeMove(SPARROW, null, mc(0, 0));
		redFirstGame.makeMove(BUTTERFLY, null, mc(-1, 1));
		redFirstGame.makeMove(BUTTERFLY, null, mc(1, -1));
		redFirstGame.makeMove(SPARROW, null, mc(-1, 2));
		try {
			redFirstGame.makeMove(SPARROW, mc(0, 0), mc(1, 0));
			fail("Move would result in discontinuity. Exception should be thrown");
		} catch (HantoException e) {

		}

	}

	@Test
	public void tryToRemovePiece() throws HantoException {
		redFirstGame.makeMove(BUTTERFLY, null, mc(0, 0));
		redFirstGame.makeMove(BUTTERFLY, null, mc(-1, 1));

		try {
			redFirstGame.makeMove(BUTTERFLY, mc(0, 0), null);
			fail("Should not be able to remove pieces. Destination cannot be null");
		} catch (HantoException e) {
			// desired case
		}		
	}

	@Test
	public void openingLargeEnoughForWalk() throws HantoException {
		redFirstGame.makeMove(SPARROW, null, mc(0, 0));
		redFirstGame.makeMove(SPARROW, null, mc(-1, 1));
		redFirstGame.makeMove(BUTTERFLY, null, mc(1, -1));
		redFirstGame.makeMove(BUTTERFLY, null, mc(-1, 2));
		redFirstGame.makeMove(SPARROW, null, mc(2, -1));
		redFirstGame.makeMove(SPARROW, null, mc(0, 2));
		redFirstGame.makeMove(SPARROW, null, mc(2, 0));
		redFirstGame.makeMove(SPARROW, null, mc(1, 2));
		redFirstGame.makeMove(SPARROW, null, mc(3, 0));

		MoveResult mr = redFirstGame.makeMove(SPARROW, mc(1, 2), mc(1, 1));
		assertEquals(MoveResult.OK, mr);
		assertNull(redFirstGame.getPieceAt(mc(1, 2)));
		assertTrue((new TestHantoPiece(BLUE, SPARROW)).samePiece(redFirstGame.getPieceAt(mc(1, 1))));
	}

	@Test
	public void openingLargeEnoughForWalkSecondTry() throws HantoException {
		redFirstGame.makeMove(CRAB, null, mc(0, 0));
		redFirstGame.makeMove(SPARROW, null, mc(-1, 1));
		redFirstGame.makeMove(BUTTERFLY, null, mc(1, -1));
		redFirstGame.makeMove(BUTTERFLY, null, mc(-1, 2));
		redFirstGame.makeMove(SPARROW, null, mc(2, -1));
		redFirstGame.makeMove(SPARROW, null, mc(0, 2));
		redFirstGame.makeMove(SPARROW, null, mc(2, 0));
		redFirstGame.makeMove(CRAB, null, mc(1, 2));
		redFirstGame.makeMove(SPARROW, null, mc(3, 0));
		redFirstGame.makeMove(CRAB, mc(1, 2), mc(1, 1));
		MoveResult mr = redFirstGame.makeMove(CRAB, mc(0, 0), mc(0, 1));
		assertEquals(MoveResult.OK, mr);
		assertNull(redFirstGame.getPieceAt(mc(0, 0)));
		assertTrue((new TestHantoPiece(RED, CRAB)).samePiece(redFirstGame.getPieceAt(mc(0, 1))));
	}

	@Test
	public void noPlaceToMove() throws HantoException {
		redFirstGame.makeMove(BUTTERFLY, null, mc(0, 0));
		redFirstGame.makeMove(BUTTERFLY, null, mc(-1, 1));
		redFirstGame.makeMove(SPARROW, null, mc(1, -1));
		redFirstGame.makeMove(SPARROW, null, mc(-1, 2));
		redFirstGame.makeMove(SPARROW,  null,  mc(1, 0));
		redFirstGame.makeMove(SPARROW, mc(-1, 2), mc(0, 1));
		try {
			redFirstGame.makeMove(BUTTERFLY, mc(0, 0), mc(1, 0));
			fail("Space already occupied. Should throw exception");
		} catch (HantoException e) {
			// desired state
		}
	}

	@Test
	public void moveRedToNotConnectedWithOtherReds() throws HantoException {
		redFirstGame.makeMove(BUTTERFLY, null, mc(0, 0));
		redFirstGame.makeMove(BUTTERFLY, null, mc(-1, 1));
		redFirstGame.makeMove(SPARROW, null, mc(1, -1));
		redFirstGame.makeMove(SPARROW, null, mc(-1, 2));
		redFirstGame.makeMove(SPARROW,  null,  mc(1, 0));
		redFirstGame.makeMove(SPARROW, mc(-1, 2), mc(0, 1));

		MoveResult mr = redFirstGame.makeMove(BUTTERFLY, mc(0, 0), mc(-1, 0));
		assertEquals(MoveResult.OK, mr);
		assertNull(redFirstGame.getPieceAt(mc(0, 0)));
		assertTrue((new TestHantoPiece(RED, BUTTERFLY)).samePiece(redFirstGame.getPieceAt(mc(-1, 0))));
	}

	@Test
	public void tryToMoveTwoSpaces() throws HantoException {
		blueFirstGame.makeMove(BUTTERFLY, null, mc(0, 0));
		blueFirstGame.makeMove(BUTTERFLY, null, mc(-1, 1));
		blueFirstGame.makeMove(SPARROW, null, mc(1, -1));
		blueFirstGame.makeMove(SPARROW, null, mc(-1, 2));
		blueFirstGame.makeMove(SPARROW,  null,  mc(1, 0));
		blueFirstGame.makeMove(SPARROW, mc(-1, 2), mc(0, 1));
		try {
			blueFirstGame.makeMove(BUTTERFLY, mc(0, 0), mc(-2, 1));
			fail("Cannot move butterfly two spaces at once in delta hanto");
		} catch (HantoException e) {
			// desired state
		}
	}

	@Test
	public void movePieceToSameSpot() throws HantoException {
		blueFirstGame.makeMove(BUTTERFLY, null, mc(0, 0));
		blueFirstGame.makeMove(BUTTERFLY, null, mc(-1, 1));
		try {
			blueFirstGame.makeMove(BUTTERFLY, mc(0, 0), mc(0, 0));
			fail("Cannot walk piece 0 squares. Must move some");
		} catch (HantoException e) {
			// desired state
		}
	}

	@Test
	public void playMoreSparrowsThanHavePlayerOne() throws HantoException {	
		blueFirstGame.makeMove(SPARROW, null, mc(0, 0));
		blueFirstGame.makeMove(SPARROW, null, mc(1, -1));
		blueFirstGame.makeMove(SPARROW, null, mc(-1, 1));
		blueFirstGame.makeMove(SPARROW, null, mc(2, -2));
		blueFirstGame.makeMove(SPARROW, null, mc(-2, 2));
		blueFirstGame.makeMove(SPARROW, null, mc(3, -3));
		blueFirstGame.makeMove(BUTTERFLY, null, mc(-3, 3));
		blueFirstGame.makeMove(BUTTERFLY, null, mc(4, -4));
		blueFirstGame.makeMove(SPARROW, null, mc(-4, 4));
		blueFirstGame.makeMove(SPARROW, null, mc(5, -5));
		try {
			blueFirstGame.makeMove(SPARROW, null, mc(-5, 5));
			fail("Cannot place any more sparrow pieces at this point. Out of pieces.");
		} catch (HantoException e) {
			// desired state
		}
	}


	// test try to place more sparrows than have

	@Test
	public void playMoreSparrowsThanHavePlayerTwo() throws HantoException {	
		blueFirstGame.makeMove(SPARROW, null, mc(0, 0));
		blueFirstGame.makeMove(SPARROW, null, mc(1, -1));
		blueFirstGame.makeMove(SPARROW, null, mc(-1, 1));
		blueFirstGame.makeMove(SPARROW, null, mc(2, -2));
		blueFirstGame.makeMove(SPARROW, null, mc(-2, 2));
		blueFirstGame.makeMove(SPARROW, null, mc(3, -3));
		blueFirstGame.makeMove(BUTTERFLY, null, mc(-3, 3));
		blueFirstGame.makeMove(BUTTERFLY, null, mc(4, -4));
		blueFirstGame.makeMove(SPARROW, null, mc(-4, 4));
		blueFirstGame.makeMove(SPARROW, null, mc(5, -5));
		blueFirstGame.makeMove(SPARROW, mc(-4, 4), mc(-3, 4));

		try {
			blueFirstGame.makeMove(SPARROW, null, mc(6, -6));
			fail("Cannot place any more sparrow pieces at this point. Out of pieces.");
		} catch (HantoException e) {
			// desired state
		}
	}

	@Test
	public void butterfliesSurroundedSimultaneously() throws HantoException {
		blueFirstGame.makeMove(BUTTERFLY, null, mc(0, 0));
		blueFirstGame.makeMove(BUTTERFLY, null, mc(0, -1));
		blueFirstGame.makeMove(SPARROW, null, mc(0, 1));
		blueFirstGame.makeMove(SPARROW, null, mc(0, -2));

		blueFirstGame.makeMove(SPARROW, null, mc(-1, 1));
		blueFirstGame.makeMove(SPARROW, null, mc(-1, -1));
		blueFirstGame.makeMove(SPARROW, null, mc(1, 0));
		blueFirstGame.makeMove(SPARROW, null, mc(1, -2));

		blueFirstGame.makeMove(SPARROW, null, mc(2, -1));
		blueFirstGame.makeMove(SPARROW, null, mc(-2, 0));
		blueFirstGame.makeMove(SPARROW, mc(2, -1), mc(1, -1));
		MoveResult mr = blueFirstGame.makeMove(SPARROW, mc(-2, 0), mc(-1, 0));
		assertEquals(MoveResult.DRAW, mr);
	}

	@Test
	public void blueButterflySurrounded() throws HantoException {
		blueFirstGame.makeMove(BUTTERFLY, null, mc(0, 0));
		blueFirstGame.makeMove(BUTTERFLY, null, mc(0, -1));
		blueFirstGame.makeMove(SPARROW, null, mc(0, 1));
		blueFirstGame.makeMove(SPARROW, null, mc(0, -2));

		blueFirstGame.makeMove(SPARROW, null, mc(-1, 1));
		blueFirstGame.makeMove(SPARROW, null, mc(-1, -1));
		blueFirstGame.makeMove(SPARROW, null, mc(1, 0));
		blueFirstGame.makeMove(SPARROW, null, mc(1, -3));

		blueFirstGame.makeMove(SPARROW, null, mc(2, -1));
		blueFirstGame.makeMove(SPARROW, null, mc(-2, 0));
		blueFirstGame.makeMove(SPARROW, mc(2, -1), mc(1, -1));
		MoveResult mr = blueFirstGame.makeMove(SPARROW, mc(-2, 0), mc(-1, 0));
		assertEquals(MoveResult.RED_WINS, mr);
	}

	@Test
	public void redButterflySurrounded() throws HantoException {
		blueFirstGame.makeMove(BUTTERFLY, null, mc(0, 0));
		blueFirstGame.makeMove(BUTTERFLY, null, mc(0, -1));
		blueFirstGame.makeMove(SPARROW, null, mc(0, 1));
		blueFirstGame.makeMove(SPARROW, null, mc(0, -2));

		blueFirstGame.makeMove(SPARROW, null, mc(-1, 2));
		blueFirstGame.makeMove(SPARROW, null, mc(-1, -1));
		blueFirstGame.makeMove(SPARROW, null, mc(1, 0));
		blueFirstGame.makeMove(SPARROW, null, mc(1, -2));

		blueFirstGame.makeMove(SPARROW, null, mc(2, -1));
		blueFirstGame.makeMove(SPARROW, null, mc(-2, 0));
		blueFirstGame.makeMove(SPARROW, mc(2, -1), mc(1, -1));
		MoveResult mr = blueFirstGame.makeMove(SPARROW, mc(-2, 0), mc(-1, 0));
		assertEquals(MoveResult.BLUE_WINS, mr);
	}

	@Test
	public void redGoesFirstBlueWins() throws HantoException {
		redFirstGame.makeMove(BUTTERFLY, null, mc(0, 0));
		redFirstGame.makeMove(BUTTERFLY, null, mc(0, -1));
		redFirstGame.makeMove(SPARROW, null, mc(0, 1));
		redFirstGame.makeMove(SPARROW, null, mc(0, -2));

		redFirstGame.makeMove(SPARROW, null, mc(-1, 1));
		redFirstGame.makeMove(SPARROW, null, mc(-1, -1));
		redFirstGame.makeMove(SPARROW, null, mc(1, 0));
		redFirstGame.makeMove(SPARROW, null, mc(1, -3));

		redFirstGame.makeMove(SPARROW, null, mc(2, -1));
		redFirstGame.makeMove(SPARROW, null, mc(-2, 0));
		redFirstGame.makeMove(SPARROW, mc(2, -1), mc(1, -1));
		MoveResult mr = redFirstGame.makeMove(SPARROW, mc(-2, 0), mc(-1, 0));
		assertEquals(MoveResult.BLUE_WINS, mr);
	}

	@Test
	public void redGoesFirstRedWins() throws HantoException {
		redFirstGame.makeMove(BUTTERFLY, null, mc(0, 0));
		redFirstGame.makeMove(BUTTERFLY, null, mc(0, -1));
		redFirstGame.makeMove(SPARROW, null, mc(0, 1));
		redFirstGame.makeMove(SPARROW, null, mc(0, -2));

		redFirstGame.makeMove(SPARROW, null, mc(-1, 2));
		redFirstGame.makeMove(SPARROW, null, mc(-1, -1));
		redFirstGame.makeMove(SPARROW, null, mc(1, 0));
		redFirstGame.makeMove(SPARROW, null, mc(1, -2));

		redFirstGame.makeMove(SPARROW, null, mc(2, -1));
		redFirstGame.makeMove(SPARROW, null, mc(-2, 0));
		redFirstGame.makeMove(SPARROW, mc(2, -1), mc(1, -1));
		MoveResult mr = redFirstGame.makeMove(SPARROW, mc(-2, 0), mc(-1, 0));
		assertEquals(MoveResult.RED_WINS, mr);
	}

	@Test
	public void exceptionAfterRedWins() throws HantoException {
		redFirstGame.makeMove(BUTTERFLY, null, mc(0, 0));
		redFirstGame.makeMove(BUTTERFLY, null, mc(0, -1));
		redFirstGame.makeMove(SPARROW, null, mc(0, 1));
		redFirstGame.makeMove(SPARROW, null, mc(0, -2));

		redFirstGame.makeMove(SPARROW, null, mc(-1, 2));
		redFirstGame.makeMove(SPARROW, null, mc(-1, -1));
		redFirstGame.makeMove(SPARROW, null, mc(1, 0));
		redFirstGame.makeMove(SPARROW, null, mc(1, -2));

		redFirstGame.makeMove(SPARROW, null, mc(2, -1));
		redFirstGame.makeMove(SPARROW, null, mc(-2, 0));
		redFirstGame.makeMove(SPARROW, mc(2, -1), mc(1, -1));
		redFirstGame.makeMove(SPARROW, mc(-2, 0), mc(-1, 0));

		try {
			redFirstGame.makeMove(SPARROW, null, mc(0, 2));
			fail("Game ended, exception should've been thrown");
		} catch (HantoException e) {
			// desired state
		}
	}

	@Test
	public void exceptionAfterBlueWins() throws HantoException {
		redFirstGame.makeMove(BUTTERFLY, null, mc(0, 0));
		redFirstGame.makeMove(BUTTERFLY, null, mc(0, -1));
		redFirstGame.makeMove(SPARROW, null, mc(0, 1));
		redFirstGame.makeMove(SPARROW, null, mc(0, -2));

		redFirstGame.makeMove(SPARROW, null, mc(-1, 1));
		redFirstGame.makeMove(SPARROW, null, mc(-1, -1));
		redFirstGame.makeMove(SPARROW, null, mc(1, 0));
		redFirstGame.makeMove(SPARROW, null, mc(1, -3));

		redFirstGame.makeMove(SPARROW, null, mc(2, -1));
		redFirstGame.makeMove(SPARROW, null, mc(-2, 0));
		redFirstGame.makeMove(SPARROW, mc(2, -1), mc(1, -1));
		redFirstGame.makeMove(SPARROW, mc(-2, 0), mc(-1, 0));

		try {
			redFirstGame.makeMove(SPARROW, null, mc(0, 2));
			fail("Game ended, exception should've been thrown");
		} catch (HantoException e) {
			// desired state
		}
	}

	// ---------------------------- Tests (TDD) specifically for Delta Hanto -------- 
	// test CRAB walking 1
	@Test 
	public void crabWalksOne() throws HantoException {
		redFirstGame.makeMove(BUTTERFLY, null, mc(0, 0));
		redFirstGame.makeMove(BUTTERFLY, null, mc(0, -1));
		redFirstGame.makeMove(CRAB, null, mc(0, 1));
		redFirstGame.makeMove(SPARROW,  null, mc(0, -2));
		MoveResult mr = redFirstGame.makeMove(CRAB, mc(0, 1), mc(1, 0));
		assertEquals(MoveResult.OK, mr);
		assertTrue((new TestHantoPiece(RED, CRAB)).samePiece(redFirstGame.getPieceAt(mc(1, 0))));
		assertNull(redFirstGame.getPieceAt(mc(0, 1)));
	}

	// test CRAB walking 2
	@Test 
	public void crabWalksTwo() throws HantoException {
		redFirstGame.makeMove(BUTTERFLY, null, mc(0, 0));
		redFirstGame.makeMove(BUTTERFLY, null, mc(0, -1));
		redFirstGame.makeMove(CRAB, null, mc(0, 1));
		redFirstGame.makeMove(SPARROW,  null, mc(0, -2));
		MoveResult mr = redFirstGame.makeMove(CRAB, mc(0, 1), mc(1, -1));
		assertEquals(MoveResult.OK, mr);
		assertTrue((new TestHantoPiece(RED, CRAB)).samePiece(redFirstGame.getPieceAt(mc(1, -1))));
		assertNull(redFirstGame.getPieceAt(mc(0, 1)));
	}

	// test CRAB walking 3
	@Test 
	public void crabWalksThree() throws HantoException {
		redFirstGame.makeMove(BUTTERFLY, null, mc(0, 0));
		redFirstGame.makeMove(BUTTERFLY, null, mc(0, -1));
		redFirstGame.makeMove(CRAB, null, mc(0, 1));
		redFirstGame.makeMove(SPARROW,  null, mc(0, -2));
		MoveResult mr = redFirstGame.makeMove(CRAB, mc(0, 1), mc(-1, -1));
		assertEquals(MoveResult.OK, mr);
		assertTrue((new TestHantoPiece(RED, CRAB)).samePiece(redFirstGame.getPieceAt(mc(-1, -1))));
		assertNull(redFirstGame.getPieceAt(mc(0, 1)));
	}

	// test exception crab walking > 3
	@Test 
	public void crabWalksTriesToWalkFour() throws HantoException {
		redFirstGame.makeMove(BUTTERFLY, null, mc(0, 0));
		redFirstGame.makeMove(BUTTERFLY, null, mc(0, -1));
		redFirstGame.makeMove(CRAB, null, mc(0, 1));
		redFirstGame.makeMove(SPARROW,  null, mc(0, -2));
		try {
			redFirstGame.makeMove(CRAB, mc(0, 1), mc(-1, -2));
			fail("Crab should only be able to walk 3 hexes");
		} catch (HantoException e) {
			// desired case
		}
	}

	// discontinuous dest
	@Test 
	public void crabCantWalkToDiscontinusousHex() throws HantoException {
		redFirstGame.makeMove(BUTTERFLY, null, mc(0, 0));
		redFirstGame.makeMove(BUTTERFLY, null, mc(0, -1));
		redFirstGame.makeMove(CRAB, null, mc(0, 1));
		redFirstGame.makeMove(SPARROW,  null, mc(0, -2));
		try {
			redFirstGame.makeMove(CRAB, mc(0, 1), mc(-1, 2));
			fail("destination hex is discontinuous");
		} catch (HantoException e) {
			// desired case
		}
	}

	// discontinuous path
	@Test 
	public void crabCantHaveDiscontinutiyWhileWalking() throws HantoException {
		redFirstGame.makeMove(BUTTERFLY, null, mc(0, 0));
		redFirstGame.makeMove(BUTTERFLY, null, mc(-1, 1));
		redFirstGame.makeMove(SPARROW, null, mc(1, 0));
		redFirstGame.makeMove(SPARROW, null, mc(-2, 2));
		redFirstGame.makeMove(CRAB, null, mc(2, 0));
		redFirstGame.makeMove(CRAB, null, mc(-2, 3));
		redFirstGame.makeMove(SPARROW, null, mc(2, 1));
		try {
			redFirstGame.makeMove(CRAB, mc(-2, 3), mc(1, 2));
			fail("Only valid path has discontinuity");
		} catch (HantoException e) {
			// desired state
		}
	}

	// test sparrow flies (various lengths)
	@Test
	public void sparrowFliesFromSidesOfLine() throws HantoException {
		blueFirstGame.makeMove(CRAB, null, mc(0, 0));
		blueFirstGame.makeMove(CRAB, null, mc(1, -1));
		blueFirstGame.makeMove(CRAB, null, mc(-1, 1));
		blueFirstGame.makeMove(CRAB, null, mc(2, -2));
		blueFirstGame.makeMove(CRAB, null, mc(-2, 2));
		blueFirstGame.makeMove(CRAB, null, mc(3, -3));
		blueFirstGame.makeMove(BUTTERFLY, null, mc(-3, 3));
		blueFirstGame.makeMove(BUTTERFLY, null, mc(4, -4));
		blueFirstGame.makeMove(CRAB, null, mc(-4, 4));
		blueFirstGame.makeMove(CRAB, null, mc(5, -5));
		blueFirstGame.makeMove(SPARROW, null, mc(-5, 5));
		blueFirstGame.makeMove(SPARROW, null, mc(6, -6));
		MoveResult mr = blueFirstGame.makeMove(SPARROW, mc(-5, 5), mc(7, -7));
		assertEquals(MoveResult.OK, mr);
		assertTrue((new TestHantoPiece(BLUE, SPARROW)).samePiece(blueFirstGame.getPieceAt(new TestHantoCoordinate(7, -7))));
		assertNull(blueFirstGame.getPieceAt(new TestHantoCoordinate(-5, 5)));
	}


	// test sparrow flying makes non-contiguous
	@Test
	public void sparrowLeavesDiscontinuity() throws HantoException {
		blueFirstGame.makeMove(CRAB, null, mc(0, 0));
		blueFirstGame.makeMove(CRAB, null, mc(1, -1));
		blueFirstGame.makeMove(CRAB, null, mc(-1, 1));
		blueFirstGame.makeMove(CRAB, null, mc(2, -2));
		blueFirstGame.makeMove(CRAB, null, mc(-2, 2));
		blueFirstGame.makeMove(CRAB, null, mc(3, -3));
		blueFirstGame.makeMove(BUTTERFLY, null, mc(-3, 3));
		blueFirstGame.makeMove(BUTTERFLY, null, mc(4, -4));
		blueFirstGame.makeMove(SPARROW, null, mc(-4, 4));
		blueFirstGame.makeMove(CRAB, null, mc(5, -5));
		blueFirstGame.makeMove(SPARROW, null, mc(-5, 5));
		blueFirstGame.makeMove(SPARROW, null, mc(6, -6));
		try { 
			blueFirstGame.makeMove(SPARROW, mc(-4, 4), mc(7, -7));
			fail("Move left discontinuity in piece placement");
		} catch (HantoException e) {
			// desired state
		}
	}

	// test no move limit 
	@Test
	public void noMoveLimit() throws HantoException {
		// 4 moves
		blueFirstGame.makeMove(BUTTERFLY, null, mc(0, 0));
		blueFirstGame.makeMove(BUTTERFLY, null, mc(0, -1));
		blueFirstGame.makeMove(CRAB, null, mc(0, 1));
		blueFirstGame.makeMove(CRAB, null, mc(0, -2));

		// 8 moves
		blueFirstGame.makeMove(SPARROW, null, mc(-1, 2));
		blueFirstGame.makeMove(SPARROW, null, mc(-1, -1));
		blueFirstGame.makeMove(SPARROW, null, mc(1, 0));
		blueFirstGame.makeMove(SPARROW, null, mc(1, -2));

		// 12 moves
		blueFirstGame.makeMove(SPARROW, null, mc(2, -1));
		blueFirstGame.makeMove(SPARROW, null, mc(-2, 0));
		blueFirstGame.makeMove(SPARROW, mc(2, -1), mc(1, -1));
		blueFirstGame.makeMove(SPARROW, null, mc(0, -3));

		// 16 moves
		blueFirstGame.makeMove(SPARROW, null, mc(0, 2));
		blueFirstGame.makeMove(SPARROW, mc(0, -3), mc(-1, -2));
		blueFirstGame.makeMove(SPARROW, mc(0, 2), mc(1, 1));
		blueFirstGame.makeMove(SPARROW, mc(-1, -2), mc(0, -3));

		// play a lot of times because no move limit
		for (int i = 0; i < 20; i++) {
			assertEquals(MoveResult.OK, blueFirstGame.makeMove(SPARROW, mc(1, 1), mc(0, 2)));
			assertEquals(MoveResult.OK, blueFirstGame.makeMove(SPARROW, mc(0, -3), mc(-1, -2)));
			assertEquals(MoveResult.OK, blueFirstGame.makeMove(SPARROW, mc(0, 2), mc(1, 1)));
			assertEquals(MoveResult.OK, blueFirstGame.makeMove(SPARROW, mc(-1, -2), mc(0, -3)));
		}
	
	}



	// test blue resigns
	@Test
	public void blueResignsRightAway() throws HantoException {
		MoveResult mr = blueFirstGame.makeMove(null, null, null);
		assertEquals(MoveResult.RED_WINS, mr);
	}

	@Test
	public void blueResignsAfterSomeTurns() throws HantoException {
		redFirstGame.makeMove(SPARROW, null, mc(0, 0));
		redFirstGame.makeMove(SPARROW, null, mc(1, -1));
		redFirstGame.makeMove(SPARROW, null, mc(-1, 1));
		redFirstGame.makeMove(SPARROW, null, mc(2, -2));
		redFirstGame.makeMove(SPARROW, null, mc(-2, 2));
		redFirstGame.makeMove(SPARROW, null, mc(3, -3));
		redFirstGame.makeMove(BUTTERFLY, null, mc(-3, 3));
		redFirstGame.makeMove(BUTTERFLY, null, mc(4, -4));
		redFirstGame.makeMove(SPARROW, null, mc(-4, 4));
		redFirstGame.makeMove(SPARROW, null, mc(5, -5));
		redFirstGame.makeMove(SPARROW, mc(-4, 4), mc(-3, 4));
		MoveResult mr = redFirstGame.makeMove(null, null, null);
		assertEquals(MoveResult.RED_WINS, mr);
	}

	// test red resigns
	@Test
	public void redResignsRightAway() throws HantoException {
		blueFirstGame.makeMove(CRAB, null, mc(0, 0));
		MoveResult mr = blueFirstGame.makeMove(null, null, null);
		assertEquals(MoveResult.BLUE_WINS, mr);
	}

	@Test
	public void redResignsAfterSomeTurns() throws HantoException {
		redFirstGame.makeMove(SPARROW, null, mc(0, 0));
		redFirstGame.makeMove(SPARROW, null, mc(1, -1));
		redFirstGame.makeMove(SPARROW, null, mc(-1, 1));
		redFirstGame.makeMove(SPARROW, null, mc(2, -2));
		redFirstGame.makeMove(SPARROW, null, mc(-2, 2));
		redFirstGame.makeMove(SPARROW, null, mc(3, -3));
		redFirstGame.makeMove(BUTTERFLY, null, mc(-3, 3));
		redFirstGame.makeMove(BUTTERFLY, null, mc(4, -4));
		redFirstGame.makeMove(SPARROW, null, mc(-4, 4));
		redFirstGame.makeMove(SPARROW, null, mc(5, -5));
		redFirstGame.makeMove(SPARROW, mc(-4, 4), mc(-3, 4));
		redFirstGame.makeMove(CRAB, null, mc(5, -4));
		MoveResult mr = redFirstGame.makeMove(null, null, null);
		assertEquals(MoveResult.BLUE_WINS, mr);
	}


	// test try to play after resign
	@Test
	public void bluePlaysAfterRedResigns() throws HantoException {
		redFirstGame.makeMove(SPARROW, null, mc(0, 0));
		redFirstGame.makeMove(SPARROW, null, mc(1, -1));
		redFirstGame.makeMove(SPARROW, null, mc(-1, 1));
		redFirstGame.makeMove(SPARROW, null, mc(2, -2));
		redFirstGame.makeMove(SPARROW, null, mc(-2, 2));
		redFirstGame.makeMove(SPARROW, null, mc(3, -3));
		redFirstGame.makeMove(BUTTERFLY, null, mc(-3, 3));
		redFirstGame.makeMove(BUTTERFLY, null, mc(4, -4));
		redFirstGame.makeMove(SPARROW, null, mc(-4, 4));
		redFirstGame.makeMove(SPARROW, null, mc(5, -5));
		redFirstGame.makeMove(SPARROW, mc(-4, 4), mc(-3, 4));
		redFirstGame.makeMove(CRAB, null, mc(5, -4));
		redFirstGame.makeMove(null, null, null);
		try {
			redFirstGame.makeMove(CRAB, null, mc(6, -4));
			fail("Game is already over");
		} catch (HantoException e) {
			// desired case
		}
	}

	@Test
	public void redPlaysAfterBlueResigns() throws HantoException {
		redFirstGame.makeMove(SPARROW, null, mc(0, 0));
		redFirstGame.makeMove(SPARROW, null, mc(1, -1));
		redFirstGame.makeMove(SPARROW, null, mc(-1, 1));
		redFirstGame.makeMove(SPARROW, null, mc(2, -2));
		redFirstGame.makeMove(SPARROW, null, mc(-2, 2));
		redFirstGame.makeMove(SPARROW, null, mc(3, -3));
		redFirstGame.makeMove(BUTTERFLY, null, mc(-3, 3));
		redFirstGame.makeMove(BUTTERFLY, null, mc(4, -4));
		redFirstGame.makeMove(SPARROW, null, mc(-4, 4));
		redFirstGame.makeMove(SPARROW, null, mc(5, -5));
		redFirstGame.makeMove(SPARROW, mc(-4, 4), mc(-3, 4));
		redFirstGame.makeMove(null, null, null);
		try {
			redFirstGame.makeMove(CRAB, null, mc(-3, 3));
			fail("Game has already ended");
		} catch (HantoException e) {
			// desired case
		}
	}

	// test intermediate step of crab walking does not have open path
	@Test
	public void intermediteStepOfCrabWalkDoesNotHaveOpenPath() throws HantoException {
		blueFirstGame.makeMove(BUTTERFLY, null, mc(0, 0));
		blueFirstGame.makeMove(BUTTERFLY, null, mc(-1, 0));
		blueFirstGame.makeMove(SPARROW, null, mc(0, 1));
		blueFirstGame.makeMove(SPARROW, null, mc(-2, 0));
		blueFirstGame.makeMove(CRAB, null, mc(-1, 2));
		blueFirstGame.makeMove(CRAB, null, mc(-3, 1));
		blueFirstGame.makeMove(SPARROW, null, mc(-2, 2));
		try {
			blueFirstGame.makeMove(CRAB, mc(-3, 1), mc(-1, 1));
			fail("No opening to destination");
		} catch (HantoException e) {
			// desired state
		}
	}

	// test sparrow doesn't need opening
	@Test
	public void sparrowCanLeaveHole() throws HantoException {
		redFirstGame.makeMove(SPARROW, null, mc(0, 0));
		redFirstGame.makeMove(BUTTERFLY, null, mc(1, 0));
		redFirstGame.makeMove(BUTTERFLY, null, mc(0, -1));
		redFirstGame.makeMove(SPARROW, null, mc(2, -1));
		redFirstGame.makeMove(CRAB, null, mc(-1, 0));
		redFirstGame.makeMove(SPARROW, mc(2, -1), mc(1, -1));
		redFirstGame.makeMove(CRAB, null, mc(-1, 1));
		redFirstGame.makeMove(CRAB, null, mc(2, -1));
		redFirstGame.makeMove(SPARROW, null, mc(-1, 2));
		redFirstGame.makeMove(CRAB, null, mc(2, -2));
		redFirstGame.makeMove(SPARROW, mc(-1,2), mc(0, 1));
		redFirstGame.makeMove(CRAB, null, mc(2, 0));
		MoveResult mr = redFirstGame.makeMove(SPARROW, mc(0, 0), mc(2, -3));
		assertEquals(MoveResult.OK, mr);
		assertTrue((new TestHantoPiece(RED, SPARROW)).samePiece(redFirstGame.getPieceAt(new TestHantoCoordinate(2, -3))));
		assertNull(blueFirstGame.getPieceAt(new TestHantoCoordinate(0, 0)));

	}

	@Test
	public void sparrowFliesAwayFromEverything() throws HantoException {
		blueFirstGame.makeMove(BUTTERFLY, null, mc(0, 0));
		blueFirstGame.makeMove(BUTTERFLY, null, mc(0, 1));
		blueFirstGame.makeMove(SPARROW, null, mc(0, -1));
		blueFirstGame.makeMove(CRAB,  null, mc(0, 2));
		try {
			blueFirstGame.makeMove(SPARROW, mc(0, -1), mc(0, -2));
			fail("Sparrow must be touching other pieces");
		} catch (HantoException e) {
			// desired state
		}
	}

	// test crab walks before placing butterfly
	@Test
	public void crabWalksBeforePlacingButterfly() throws HantoException {
		blueFirstGame.makeMove(CRAB, null, mc(0, 0));
		blueFirstGame.makeMove(BUTTERFLY, null, mc(0, 1));
		try {
			blueFirstGame.makeMove(CRAB, mc(0, 0), mc(1, 0));
			fail("Can't move crab before butterfly placed");
		} catch (HantoException e) {
			// desired case
		}
	}

	// test sparrow flies before placing butterfly
	@Test
	public void sparrowFliesBeforePlacingButterfly() throws HantoException {
		blueFirstGame.makeMove(SPARROW, null, mc(0, 0));
		blueFirstGame.makeMove(BUTTERFLY, null, mc(0, 1));
		try {
			blueFirstGame.makeMove(SPARROW, mc(0, 0), mc(0, 2));
			fail("Can't move sparrow before butterfly placed");
		} catch (HantoException e) {
			// desired case
		}
	}

	// test only 4 crabs
	@Test
	public void onlyFiveCrabsRed() throws HantoException {
		redFirstGame.makeMove(BUTTERFLY, null, mc(0, 0));
		redFirstGame.makeMove(BUTTERFLY, null, mc(0, 1));
		redFirstGame.makeMove(CRAB, null, mc(0, -1));
		redFirstGame.makeMove(CRAB, null, mc(0, 2));
		redFirstGame.makeMove(CRAB, null, mc(0, -2));
		redFirstGame.makeMove(CRAB, null, mc(0, 3));
		redFirstGame.makeMove(CRAB, null, mc(0, -3));
		redFirstGame.makeMove(CRAB, null, mc(0, 4));
		redFirstGame.makeMove(CRAB, null, mc(0, -4));
		redFirstGame.makeMove(CRAB, null, mc(0, 5));
		try {
			redFirstGame.makeMove(CRAB, null, mc(0, -5));
			fail("Only have 4 Crabs");
		} catch (HantoException e) {
			// desired state
		}
	}

	@Test
	public void onlyFiveCrabsBlue() throws HantoException {
		redFirstGame.makeMove(BUTTERFLY, null, mc(0, 0));
		redFirstGame.makeMove(BUTTERFLY, null, mc(0, 1));
		redFirstGame.makeMove(CRAB, null, mc(0, -1));
		redFirstGame.makeMove(CRAB, null, mc(0, 2));
		redFirstGame.makeMove(CRAB, null, mc(0, -2));
		redFirstGame.makeMove(CRAB, null, mc(0, 3));
		redFirstGame.makeMove(CRAB, null, mc(0, -3));
		redFirstGame.makeMove(CRAB, null, mc(0, 4));
		redFirstGame.makeMove(SPARROW, null, mc(0, -4));
		redFirstGame.makeMove(CRAB, null, mc(0, 5));
		redFirstGame.makeMove(CRAB, null, mc(0, -5));

		try {
			redFirstGame.makeMove(CRAB, null, mc(0, 6));
			fail("Only have 4 Crabs");
		} catch (HantoException e) {
			// desired state
		}
	}


	@Test
	public void tryToResignAfterGameOver() throws HantoException {
		blueFirstGame.makeMove(CRAB, null, mc(0, 0));
		blueFirstGame.makeMove(CRAB, null, mc(1, 0));
		blueFirstGame.makeMove(BUTTERFLY, null, mc(-1, 1));
		blueFirstGame.makeMove(BUTTERFLY, null, mc(1, 1));
		blueFirstGame.makeMove(CRAB, null, mc(-1, 2));
		blueFirstGame.makeMove(BUTTERFLY, mc(1, 1), mc(0, 1));
		blueFirstGame.makeMove(CRAB, null, mc(-1, 3));
		blueFirstGame.makeMove(CRAB, null, mc(1, 1));
		MoveResult mr = blueFirstGame.makeMove(CRAB, mc(-1, 3), mc(0, 2));
		assertEquals(MoveResult.BLUE_WINS, mr);
		try {
			blueFirstGame.makeMove(null, null, null);
			fail("Game already over. Cannot resign");
		} catch (HantoException e) {
			// desired state
		}

	}

	// retest end of game scenarios // TODO



	// -- board tests


	// Helper methods
	private HantoCoordinate mc(int x, int y)
	{
		return new TestHantoCoordinate(x, y);
	}
}
