/*******************************************************************************
 * This files was developed for CS4233: Object-Oriented Analysis & Design.
 * The course was taken at Worcester Polytechnic Institute.
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 * 
 * Copyright Â©2016 Gary F. Pollice
 *******************************************************************************/

package hanto.studentThhughes.beta;



import java.util.*;

import hanto.common.*;
import hanto.studentThhughes.common.*;
import hanto.studentThhughes.common.board.Board;
import hanto.studentThhughes.common.board.BoardImpl;
import hanto.studentThhughes.common.colorManager.ColorManager;
import hanto.studentThhughes.common.coordinate.HantoCoordinateImpl;
import hanto.studentThhughes.common.frontier.Frontier;
import hanto.studentThhughes.common.frontier.FrontierImpl;
import hanto.studentThhughes.common.hantoPiece.HantoPieceImpl;

import static hanto.common.HantoPieceType.*;
import static hanto.common.HantoPlayerColor.*;


/**
 * The implementation of Beta Hanto.
 * @version Mar 16, 2016
 */
public class BetaHantoGameRefactored implements HantoGame
{
	private boolean firstMove = true;
	private boolean gameOver = false;
//	private HantoPlayerColor nextPlayerColor = null;
	private Queue<HantoPieceType> validPieces = new LinkedList<HantoPieceType>();
	private int blueMoves = 0;
	private int redMoves = 0;
	private Map<HantoPieceType,Integer> bluePieceMap = new HashMap<HantoPieceType, Integer>();
	private Map<HantoPieceType,Integer> redPieceMap = new HashMap<HantoPieceType, Integer>();
	private Map<HantoCoordinate,Boolean> blueButterflyMap = new HashMap<HantoCoordinate,Boolean>();
	private Map<HantoCoordinate,Boolean> redButterflyMap = new HashMap<HantoCoordinate,Boolean>();
	
	
	private ColorManager hantoColorManager;
	private Frontier hantoFrontier = new FrontierImpl();
	private Board hantoBoard = new BoardImpl();
	private MoveCounter hantoMC = new MoveCounter();
	
	
	/**
	 * 
	 * 
	 * @param firstMovePlayer
	 */
	public BetaHantoGameRefactored(HantoPlayerColor firstMovePlayer){
		hantoColorManager = new ColorManager(firstMovePlayer);
		
		// Fill the list: 
		validPieces.add(HantoPieceType.SPARROW);
		validPieces.add(HantoPieceType.BUTTERFLY);
		
	}
	

	/*
	 * @see hanto.common.HantoGame#makeMove(hanto.common.HantoPieceType, hanto.common.HantoCoordinate, hanto.common.HantoCoordinate)
	 */
	@Override
	public MoveResult makeMove(HantoPieceType pieceType, HantoCoordinate from,
			HantoCoordinate to) throws HantoException
	{
		if (gameOver){
			throw new HantoException("Illegal Move: Game has terminated");
		}
		// Ensure the coordinates are 'safe' meaning they contain equals and hash
		HantoCoordinate safeTo = null; 
		if (to != null) safeTo = new HantoCoordinateImpl(to);
		if (to == null) throw new HantoException("There Must be a To location specified for Beta Hanto");
		
		if (from != null){
			throw new HantoException("Illegal Move: Cannot Move Pieces In BetaHanto");
		}
		if (!validPieces.contains(pieceType)) throw new HantoException("Invalid Piece");						
		
		
		// Check if it's a valid first move piece
		if(firstMove){
			if (!safeTo.equals(new HantoCoordinateImpl(0,0))){
				throw new HantoException("Invalid location for first move");
			}

			cachePiece(pieceType, safeTo);
		}
		// Check if it's a valid piece if it's not the first move
		else {

			hantoBoard.isLocationOccupied(safeTo);
			
			if(!hantoFrontier.inFrontier(safeTo)){
				throw new HantoException("Invalid Locaiton: Cannot Move There");
			}
			if(!isLegalBoardMove(pieceType, safeTo)){
				throw new HantoException("Illegal Move: Cannot Make that Move");
			}
			
			if(pieceType == BUTTERFLY && getCurrentPlayerMap().containsKey(BUTTERFLY)){
				throw new HantoException("Illegal Move: Cannot place two butterflys");
			}
			// If the item is a butterfly, cehck if there's already been a butterfly
			cachePiece(pieceType, safeTo);
		}
		
		return evaluateBoardState();
		
	}

	/**
	 * This internally caches the piece in a frontier and in a hash of pieces based off it's location
	 * @param pieceType: HantoPieceType of the piece that is being passed. 
	 * @param safeTo : location of the hantoPiece as a HantoCoordinat
	 * @throws HantoException 
	 */
	private void cachePiece(HantoPieceType pieceType, HantoCoordinate safeTo) throws HantoException {
		
		// Expand the frontier of the point being placed
		for(HantoCoordinate hc : (new HantoCoordinateImpl(safeTo).getNeighbors())){
			try{
				hantoFrontier.addToFrontier(hc);
			}catch (HantoException e){
				// Do nothing, it's probably ok.
			}
			
		}
		
		// Create the piece for internal hashing
		HantoPlayerColor curColor = hantoColorManager.getCurrentColor();
		HantoPiece movePiece = new HantoPieceImpl(curColor, pieceType);
		
		// Increment the team's move
		hantoMC.incrementNumberMoves(curColor);
		
		// Hash data for game progression
		updateCurrentPlayerMap(pieceType);
		hantoBoard.placeOnBoard(movePiece, safeTo);
		
		// Get the butterfly data and update 
		Map<HantoCoordinate,Boolean> butterflyMap = getCurrentPlayerButterflyMap();
		
		if (pieceType == BUTTERFLY){
			butterflyMap.clear();
			for (HantoCoordinate somePoint : (new HantoCoordinateImpl(safeTo)).getNeighbors()){
				butterflyMap.put(somePoint, hantoBoard.isLocationOccupied(somePoint));
			}
		}
		if (blueButterflyMap.containsKey(safeTo) && !blueButterflyMap.isEmpty()){
			blueButterflyMap.put(safeTo, hantoBoard.isLocationOccupied(safeTo));
		}
		if (redButterflyMap.containsKey(safeTo) && !redButterflyMap.isEmpty()){
			redButterflyMap.put(safeTo, hantoBoard.isLocationOccupied(safeTo));
		}
		
		
		hantoColorManager.toggelCurrentColor(); 
		firstMove = false;
	}
	
	private MoveResult evaluateBoardState()
	{
		MoveResult result = MoveResult.OK;
		int numWinners = 0;
		
		// CHECK FOR WINNER
		if (!blueButterflyMap.containsValue(false) && !blueButterflyMap.isEmpty()){
			result = MoveResult.RED_WINS;
			numWinners++;
		}
		if (!redButterflyMap.containsValue(false) && !redButterflyMap.isEmpty()){
			result = MoveResult.BLUE_WINS;
			numWinners++;
		}
		// GET DRAW CONDITION
		if (((hantoMC.getNumberMoves(BLUE) == 6 && hantoMC.getNumberMoves(RED) == 6) && (numWinners == 0)) || (numWinners == 2)){
			result = MoveResult.DRAW;
		}
		// END THE GAME
		if(result != MoveResult.OK){
			gameOver = true;
		}
		return result;
	}

	/*
	 * @see hanto.common.HantoGame#getPieceAt(hanto.common.HantoCoordinate)
	 */
	@Override
	public HantoPiece getPieceAt(HantoCoordinate where)
	{
		return hantoBoard.getFromBoard(where);
	}

	/*
	 * @see hanto.common.HantoGame#getPrintableBoard()
	 */
	@Override
	public String getPrintableBoard()
	{
		return "hello World";
	}			

	
	// LEGAL MOVE CHECKERS  ---------------------------------------------
	// LEGAL MOVE CHECKERS  ------Create Strategy Pattern Move Checker!--
	// LEGAL MOVE CHECKERS  ---------------------------------------------
	
	
	/**
	 * Checks if a legal move is being made based off the turn number and the pieces on the board
	 * @param pt : HantoPieceType -> the type of piece being played this turn
	 * @param cord : hantoCoordinate -> where the peice is being placed
	 * @return Boolean : True if the move is legal. 
	 */
	private boolean isLegalBoardMove(HantoPieceType pt, HantoCoordinate cord){
		return !(hantoMC.getNumberMoves(hantoColorManager.getCurrentColor()) == 3 && 
				!((getCurrentPlayerMap().containsKey(BUTTERFLY)) ^ pt == BUTTERFLY));
	}
	
	
	// MAP MANAGEMENT COMMANDS  ---------------------------------------------
	// MAP MANAGEMENT COMMANDS  -----Map Class? ----------
	// MAP MANAGEMENT COMMANDS  ---------------------------------------------
	
	private Map<HantoPieceType,Integer> getCurrentPlayerMap(){
		Map<HantoPieceType,Integer> resultMap = null;
		if (hantoColorManager.getCurrentColor() == BLUE){
			resultMap = bluePieceMap;
		}else if(hantoColorManager.getCurrentColor() == RED){
			resultMap = redPieceMap;
		}
		return resultMap;
	}
	
	private void updateCurrentPlayerMap(HantoPieceType newPiece){
		Map<HantoPieceType,Integer> updateMap = null;
		if (hantoColorManager.getCurrentColor() == BLUE){
			updateMap = bluePieceMap;
		}else if(hantoColorManager.getCurrentColor() == RED){
			updateMap = redPieceMap;
		}
		
		if(updateMap.containsKey(newPiece)){
			updateMap.put(newPiece, updateMap.get(newPiece) + 1);
		}else{
			updateMap.put(newPiece, new Integer(1));
		}
	} 
	
	private Map<HantoCoordinate,Boolean> getCurrentPlayerButterflyMap(){
		Map<HantoCoordinate,Boolean> resultMap = null;
		if (hantoColorManager.getCurrentColor() == BLUE){
			resultMap = blueButterflyMap;
		}else if(hantoColorManager.getCurrentColor() == RED){
			resultMap = redButterflyMap;
		}
		return resultMap;
	}


}
